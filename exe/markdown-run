#!/usr/bin/env ruby

require "tempfile"
require "open3"
require "fileutils"
require_relative "../lib/language_configs"

# Script to process markdown files, execute code blocks based on language,
# and insert their results back into the markdown.

def format_captured_output(captured_status_obj, captured_stderr, captured_stdout, lang_config)
  result_output = captured_stdout
  stderr_output = captured_stderr
  exit_status = captured_status_obj.exitstatus

  # JS-specific: Append stderr to result if execution failed and stderr has content
  if lang_config && lang_config[:error_handling] == :js_specific && exit_status != 0 && stderr_output && !stderr_output.strip.empty?
    result_output += "\nStderr:\n#{stderr_output.strip}" # Ensure stripping
  end
  return exit_status, result_output, stderr_output
end

def add_error_to_output(exit_status, lang_config, lang_key, result_output, stderr_output)
  warn "Code execution failed for language '#{lang_key}' with status #{exit_status}."
  warn "Stderr:\n#{stderr_output}" if stderr_output && !stderr_output.strip.empty?

  is_js_error_already_formatted = lang_config && lang_config[:error_handling] == :js_specific && result_output.include?("Stderr:")
  unless result_output.downcase.include?("error:") || is_js_error_already_formatted
    error_prefix = "Execution failed (status: #{exit_status})."
    error_prefix += " Stderr: #{stderr_output.strip}" if stderr_output && !stderr_output.strip.empty?
    result_output = "#{error_prefix}\n#{result_output}"
  end
  result_output
end

def execute_code_block(code_content, lang, temp_dir)
  captured_status_obj = nil

  lang_key = lang.downcase # Normalize lang input for lookup
  lang_config = SUPPORTED_LANGUAGES[lang_key]

  if lang_config
    exit_status = 0
    warn "Executing #{lang_key} code block..." # Generic description
    cmd_lambda = lang_config[:command]
    temp_file_suffix = lang_config[:temp_file_suffix]

    captured_stdout = nil
    if temp_file_suffix # Needs a temporary file. Use lang_key as prefix.
      Tempfile.create([ lang_key, temp_file_suffix ], temp_dir) do |temp_file|
        temp_file.write(code_content)
        temp_file.close
        # Pass temp_file.path. Lambda decides if it needs code_content directly.
        command_to_run, exec_options = cmd_lambda.call(code_content, temp_file.path)
        captured_stdout, _, captured_status_obj = Open3.capture3(command_to_run, **exec_options)
      end
    else # Direct command execution (e.g., psql that takes stdin)
      # Pass nil for temp_file_path. Lambda decides if it needs code_content.
      command_to_run, exec_options = cmd_lambda.call(code_content, nil)
      captured_stdout, captured_stderr, captured_status_obj = Open3.capture3(command_to_run, **exec_options)
    end
  else
    warn "Unsupported language: #{lang}"
    result_output = "ERROR: Unsupported language: #{lang}"
    exit_status = 1 # Indicate an error
    # captured_status_obj remains nil, so common assignments below won't run
  end

  if captured_status_obj
    exit_status, result_output, stderr_output = format_captured_output(captured_status_obj, captured_stderr, captured_stdout, lang_config)
  end

  if exit_status != 0
    result_output = add_error_to_output(exit_status, lang_config, lang_key, result_output, stderr_output)
  end
  result_output
end

class MarkdownProcessor
  def initialize(temp_dir)
    @temp_dir = temp_dir
    @output_lines = []
    @state = :outside_code_block
    @current_block_lang = ""
    @current_code_content = ""
  end

  def process_file(file_enum)
    loop do
      current_line = get_next_line(file_enum)
      break unless current_line
      
      handle_line(current_line, file_enum)
    end
    @output_lines
  end

  private

  def get_next_line(file_enum)
    file_enum.next
  rescue StopIteration
    nil
  end

  def handle_line(current_line, file_enum)
    case @state
    when :outside_code_block
      handle_outside_code_block(current_line, file_enum)
    when :inside_code_block
      handle_inside_code_block(current_line, file_enum)
    when :inside_result_block
      handle_inside_result_block(current_line, file_enum)
    end
  end

  def handle_outside_code_block(current_line, file_enum)
    if current_line.match?(/^```ruby\s+RESULT$/i)
      handle_existing_ruby_result_block(current_line, file_enum)
    elsif (match_data = current_line.match(CODE_BLOCK_START_REGEX))
      start_code_block(current_line, match_data)
    else
      @output_lines << current_line
    end
  end

  def handle_inside_code_block(current_line, file_enum)
    if current_line.strip == "```"
      end_code_block(current_line, file_enum)
    else
      accumulate_code_content(current_line)
    end
  end

  def handle_inside_result_block(current_line, file_enum)
    @output_lines << current_line
    if current_line.strip == "```"
      @state = :outside_code_block
    end
  end

  def handle_existing_ruby_result_block(current_line, file_enum)
    warn "Found existing '```ruby RESULT' block, passing through."
    @output_lines << current_line
    @state = :inside_result_block
  end

  def start_code_block(current_line, match_data)
    @output_lines << current_line
    @current_block_lang = match_data[1].downcase
    @state = :inside_code_block
    @current_code_content = ""
  end

  def accumulate_code_content(current_line)
    @current_code_content += current_line
    @output_lines << current_line
  end

  def end_code_block(current_line, file_enum)
    @output_lines << current_line
    
    decision = decide_execution(file_enum)
    
    if decision[:execute]
      execute_and_add_result(decision[:blank_line])
    else
      skip_and_pass_through_result(decision[:lines_to_pass_through], file_enum)
    end
    
    reset_code_block_state
  end

  def decide_execution(file_enum)
    peek1 = peek_next_line(file_enum)
    current_lang_config = SUPPORTED_LANGUAGES[@current_block_lang]
    is_ruby_style_result = current_lang_config && current_lang_config[:result_block_type] == "ruby"
    expected_header_regex = is_ruby_style_result ? /^```ruby\s+RESULT$/i : /^```RESULT$/i

    if peek1 && peek1.match?(expected_header_regex)
      return { execute: false, lines_to_pass_through: [file_enum.next] }
    elsif peek1 && peek1.strip == ""
      consumed_blank_line = file_enum.next
      peek2 = peek_next_line(file_enum)
      
      if peek2 && peek2.match?(expected_header_regex)
        return { execute: false, lines_to_pass_through: [consumed_blank_line, file_enum.next] }
      else
        return { execute: true, blank_line: consumed_blank_line }
      end
    else
      return { execute: true }
    end
  end

  def peek_next_line(file_enum)
    file_enum.peek
  rescue StopIteration
    nil
  end

  def execute_and_add_result(blank_line_before_new_result)
    @output_lines << blank_line_before_new_result if blank_line_before_new_result
    
    if !@current_code_content.strip.empty?
      warn "Executing #{@current_block_lang} code block..."
      result_output = execute_code_block(@current_code_content, @current_block_lang, @temp_dir)
      
      current_lang_config = SUPPORTED_LANGUAGES[@current_block_lang]
      is_ruby_style_result = current_lang_config && current_lang_config[:result_block_type] == "ruby"
      
      @output_lines << "\n" if blank_line_before_new_result.nil?
      @output_lines << (is_ruby_style_result ? "```ruby RESULT\n" : "```RESULT\n")
      @output_lines << result_output
      @output_lines << "\n" unless result_output.empty? || result_output.end_with?("\n")
      @output_lines << "```\n\n"
    else
      warn "Skipping empty code block for language '#{@current_block_lang}'."
    end
  end

  def skip_and_pass_through_result(lines_to_pass_through, file_enum)
    current_lang_config = SUPPORTED_LANGUAGES[@current_block_lang]
    is_ruby_style_result = current_lang_config && current_lang_config[:result_block_type] == "ruby"
    lang_specific_result_type = is_ruby_style_result ? "```ruby RESULT" : "```RESULT"
    
    warn "Found existing '#{lang_specific_result_type}' block for current #{@current_block_lang} block, skipping execution."
    
    @output_lines.concat(lines_to_pass_through)
    
    consume_result_block_content(file_enum)
  end

  def consume_result_block_content(file_enum)
    begin
      loop do
        result_block_line = file_enum.next
        @output_lines << result_block_line
        break if result_block_line.strip == "```"
      end
    rescue StopIteration
      warn "Warning: End of file reached inside a skipped 'RESULT' block."
    end
  end

  def reset_code_block_state
    @state = :outside_code_block
    @current_code_content = ""
  end
end

def process_markdown_file_main(input_file_path)
  unless File.exist?(input_file_path) && File.readable?(input_file_path)
    warn "Error: Input file '#{input_file_path}' not found or not readable."
    return false # Indicate failure
  end

  temp_dir = File.dirname(File.expand_path(input_file_path))
  file_enum = File.foreach(input_file_path, chomp: false).to_enum
  
  processor = MarkdownProcessor.new(temp_dir)
  output_lines = processor.process_file(file_enum)

  # Write the modified content back to the input file
  Tempfile.create([ "md_exec_out_", File.extname(input_file_path) ], temp_dir) do |temp_output_file|
    temp_output_file.write(output_lines.join(""))
    temp_output_file.close
    begin
      FileUtils.mv(temp_output_file.path, input_file_path)
    rescue Errno::EACCES, Errno::EXDEV
      warn "Atomic move failed. Falling back to copy and delete."
      FileUtils.cp(temp_output_file.path, input_file_path)
      FileUtils.rm_f(temp_output_file.path)
    end
  end
  warn "Markdown processing complete. Output written to #{input_file_path}"
  true # Indicate success
end

if ARGV.empty?
  puts "Running tests..."
  require_relative "../test_markdown_exec"
else
  process_markdown_file_main(ARGV[0])
end

